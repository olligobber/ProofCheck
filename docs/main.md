# Code Overview

ProofCheck is a collection of proof checkers for various systems of logic, with a unifying core framework to make them similar, and easy to make variants of. Each proof checker is a one page app that imports from the framework and adds its own logic symbols, deduction rules, and configuration changes for its application.

The framework consists of three major parts: Logic, UI and Data. The Logic part dictates what a formula is, what a proof is, and basic interactions such as parsing formulas, adding lines to proofs, and adding new symbols and sequents to use in proofs. The UI part dictates the behaviour of the app on screen, its rendering and interaction with the user. The Data part dictates how proofs are stored, either for saving in the browser to preserve behaviour between page reloads, or for downloading and sharing outside the app.

## Logic

### Formulas

A formula is defined using predicates, variables, and symbols. A predicate is given zero or more variables to make a formula. Variables can be either bound or free, and bound variables should only be used if a quantifier exists to bind them. Symbols come in four varieties: nullary, unary, binary, and quantifiers. A nullary symbol on its own is a formula. A unary symbol is given a formula to make a formula, and appears to the left of its input. A binary symbols is given two formulas to make a formula, and appears between its inputs. A quantifier is given a bound variable not yet bound to another quantifier and an input formula to make a formula, and the quantifier together with the variable act like a unary symbol on the formula, with the quantifier binding the variable so it can be used in the input formula. Each proof checker dictates which symbols are used in its app, and may have an option for the user to add their own symbols or aliases to other symbols when constructing a proof.

Formulas can be parsed from strings or rendered to strings, with the rule that rendering and then parsing should act as the identity on formulas. Characters are divided into some disjoint categories when parsing: whitespace, structure dictating characters, symbols, and alphanumeric characters. Structure dictating characters include parentheses and commas, while the other categories are defined by unicode standards, except where they overlap with the structure dictating characters. Tokens are made entirely of one category of character except whitespace, and whitespace is used to seperate tokens made from the same category of character, except for structure dictating characters which are one character per token and can be consecutive with whitespace optional. Tokens made of symbols are used to define the symbols of a formula, and symbols made of alphanumeric are used to define variables and predicates. A formula is then parsed as either a predicate, optionally followed by parentheses and one or more comma seperated variables as inputs to the predicate, a nullary symbol, a unary symbol followed by a formula, a binary symbol surrounded by formulas, or a quantifier and variable surrounded by brackets and followed by a formula. Order of operations has symbols with lower arity as higher precedence, meaning that a high arity symbol can take a formula with a low arity symbol as input with brackets optional, and brackets are necessary when a unary operator's input is a binary symbol expression, including a bracketed quantifier and its variable as a unary symbol. Also, unary operators have a clear precedence so brackets are not necessary, but binary operators do not, making brackets necessary. Even if brackets are not necessary, they are allowed during parsing for those unclear with precedence. A tool to aid reading precedence of rendered expressions may be added, either by adding extra brackets, showing a syntax tree, or some other visual aid.

Each string of symbols that could make up a token should have at most one meaning as one type of symbol, though using aliases a single symbol could have multiple string representations. Similarly, each string of alphanumeric characters should have at most one meaning as either a predicate or variable, with predicates having a consistent arity, and variables being consistently free or bound. These properties should be maintained constant throughout a proof, and are referred to as their type.

In order to match formulas in proofs with deduction rules, a process called matching is used to determine if one formula is more general than another, and give the substitutions required to turn the more specific formula into the more general one. Substitutions only take predicates or variables as inputs. The result of substituting a predicate is some formula with inputs corresponding to the predicate's inputs. The result of substituting a variable is another variable. Matching is done recursively, with substitutions combined if they are compatible.

A sequent is an object consisting of a list of formulas called antecedents, where order usually doesn't matter, and a single formula called the consequent. A sequent can be matched and substituted similar to a formula, where the matching of all the formulas should be consistent. Sequents should also have consistent types throughout.

### Proofs

A proof is made up of a list of lines, where each line contains assumptions, a line number, a formula, and a justification. Line numbers will be simply increasing consecutive positive integers. Assumptions are a set of integers. A line's justification will be some deduction rule, as defined by that proof checker, as well as references to previous lines by their line number. A justification may also be introduction of a custom sequent or custom symbol.

A deduction rule is usually defined by some sequents. The referenced lines' formulas and this line's formula form a sequent, which must be a more specific version of one of the deduction rule's sequents for a line of a proof to be valid. Deduction rules may have additional restrictions on their formulas, the formulas of the referenced lines, or more commonly the lines referenced by the assumptions of some of the lines, which there will be code for enforcing. Each deduction rule will also enforce constraints on the assumptions of the line, usually that the assumptions are a union of those on the referenced lines, minus one or two.

One deduction rule present in every system is the assumption rule, whose sequent has no antecedents and a single consequent that just consists of a proposition, with no constraints on the formulas, but it does require that the assumptions consist of a single number that has not been used before. Thus, any later lines that use that number as an assumption are referring to this line, which may be used in constraints for other deduction rules. The user has the choice of assumption number, since some will use the line number while others will use the smallest number not yet used.

The final result of a proof is the sequent represented by the last line's assumptions and formula.

### Custom Sequents

In some proof checkers, it is possible for the user to add custom sequents to use in proofs. It is assumed that the sequent has been proved already, and a mechanism for actually including the proof may be added in future. However this is not enforced, as the feature can also be used for meta-proofs, such as assuming a sequent is provable and showing that leads to a proof of something known not to be provable, or for showing that the relation of one formula being antecedent and another being consequent in a sequent is a preorder. Custom Sequents are introduced using a rule called Sequent Introduction, which must also specify which sequent is being introduced. The rule has no additional constraints, and the assumptions should be the union of those on the referenced lines.

The justification behind Sequent Introduction is that it could be replaced by simply inserting the proof of the sequent, with some substitutions.

### Custom Symbols

As well as the builtin symbols and symbol aliases, some proof checkers may allow the addition of custom symbols defined in terms of the existing ones. The user would specify a valid string representing the symbol, the symbol's arity, and a definition of the symbol as a formula involving propositions and existing symbols, one proposition for each input to the symbol. This definition can then be used in the proof using a rule called Definition, which must specify the symbol whose definition is being used. The rule has two sequents based on the provided definition, one for turning the symbol into its definition, and one for turning a symbol's definition into that symbol. The rule has no additional constraints, and the assumptions should be the same as the referenced line.

The justification behind Definition is that the symbol could be removed from the proof and replaced with its definition, making any uses of that rule do nothing.

Since custom symbols can reference each other in their definitions, they are given an order where symbol definitions can only use symbols defined earlier. This is the order the symbols should be shown to the user and stored.

## UI

The user interface is managed using Halogen, running on a custom monad to manage state. The monad provides methods for interacting with the logic components of the app, such as reading the current proof, custom symbols, and custom sequents, as well as adding lines to the proof, custom symbols, and custom sequents. It also allows the reporting of errors to the user and reading the currently visible errors. The monad also allows reading the currently visible window, which at the moment is either the proof, the custom symbols, the custom sequents, or the import/export window, as well as writing those. The monad also allows navigating the history of edits, such as undo, redo, and starting a new proof.

The UI is made of a component for each window, and another component to tie them together along with the menu bar at the top and any error messages at the bottom. The proof window shows the lines in the current proof, with some inputs at the bottom to allow entering a new line. The symbols window shows all the builtin symbols, aliases, and custom symbol definitions, with some inputs at the bottom to allow entering a new alias or custom symbol definition. The sequents window shows all the custom sequents, with some inputs at the bottom to allow entering new ones. The import/export window has two buttons, an import button that allows the user to choose a file that is loaded as data to replace the current proof state, and an export button that allows the user to save the current proof state as data in a file. The menu bar at the top has buttons for resetting the proof state, undoing the most recent change, and redoing undone changes, as well as one for visiting each window. The error messages at the bottom do not appear unless there is at least one error message to display, and can be clicked to be dismissed.

After every change, the UI saves the current proof state to local storage as data, and when the app is first loaded local storage is checked for valid data to load the proof state.

## Data

Proofs are stored as json data for storage and sharing. Argonaut is used for this conversion. The object consists of four fields: version, symbols, sequents, and lines.

Version is an object containing three fields: name, url, and number. Name is for the name of the system, which is used to check the correct app is being used to load the data. URL is for the URL of the app, which is used to redirect users if they attempt to load a proof into the wrong app. Number is for a version number, which is used for backwards compatibility if the format changes for a particular app.

Symbols is a list of objects, each representing either a symbol alias or a symbol definition. Each object contains a field called symbol for the string represented by that symbol. An object for a symbol alias has a field called alias for the string representing the symbol this alias links to. An object for a nullary symbol definition has a field called definition containing a string representation of the definition of that symbol. An object for a unary symbol definition has a field called prop containing a string representation of a single proposition, usually "A", and a field called definition for a string representation of the definition of that symbol using the proposition specified in the prop field. An object for a binary symbol definition has fields called propa and propb containing string representations of a single proposition each for the left and right inputs to the symbol respectively, usually "A" and "B", and a field called definition for a string representation of the definition of that symbol using the propositions specified in the propa and propb fields.
Note that the order of the symbols in the list is important, as symbol definitions should only reference earlier symbols, and uses of the Definition rule will reference the index of the symbol in this list.

Sequents is a list of objects, each of which is an object with two fields: ante and conse. Ante contains a list of string representations of formulas. Conse contains a string representation of a formula.
Note that the order of the sequents in the list is important, as uses of the Sequent Introduction rule will reference the index of the sequent in this list.

Lines is a list of objects, each of which has four fields: assumptions, formula, rule, and references. Assumptions is a list of integers. Formula is a string representation of a formula. Rule is either a string representing a deduction rule, or an object consisting of two fields, one called metarule which is a string representation of either Sequent Introduction or Definition, and the other called number which is the index of the referenced sequent of symbol in their list. References is a list of numbers, each representing the idnex of a line being referenced.

### Older Versions

Three save data versions existed before this document was written. One can be identified by having no version field at all, and is for version 1 of the Lemmon System proof checker. Another can be identified by having the number 2 in its version field, rather than an object, and is for version 2 of the Lemmon System proof checker. The last can be identified by having the string "COMP2022 1.0", rather than an object, and is for version 1 of the COMP2022 System proof checker. These older versions have some differences in their json representation, and are handled by seperate code.